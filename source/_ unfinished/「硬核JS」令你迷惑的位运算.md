## 写在前面

今天，我们来学习一下 JS 操作符中的位操作符

在 JS 这门语言的标准里，描述了一组可以用来操作数据值的操作符，其中包括 数学操作符、位操作符、关系操作符、相等操作符、布尔操作符、条件操作符以及ES7的指数操作符 等等，为什么叫操作符，因为它们都是符号构成。。。

在这一组操作符中，相比加减乘除、逻辑判断、相等、布尔等这些我们经常会用到的操作符，位运算操作符好像是极其特殊的一类，由于位操作符不是那么的直观导致很多刚入门甚至是老程序员都不太喜欢用它

大多数人都认为在写程序的过程中使用过多花里胡哨的位操作符对阅读体验是极其不好的，尽管它可能会为性能带来一些提升，但是相比下来一个项目要选择阅读体验和些许性能的话，大家大概率的会选择前者

话是这样说，但是这并不是大家不学习它的理由，假如大家都懂得位运算，那么这些 `骚操作` 就变成了常规操作，有的人可能会说就算懂得位运算，想要阅读一段位操作符组成的的代码还是需要时间来思考的，并不如通俗点写来的直观，嗯，也对，但是加上当量注释的话就差不多了吧

总之，你可以不用，但一定要会，存在即合理，任何说法都不是不学习它的理由

```js
(!(~+[])+{})[--[~+""][+[]]*[~+[]]+~~!+[]]+({}+[])[[~!+[]]*~+[]]
```

嗯，就以这一段网红代码为开头吧

在学习位运算之前，请大家一定要先阅读这篇文章 

- [「硬核JS」数字之美]() 
- [「硬核JS」数字之美]() 
- [「硬核JS」数字之美]() 

重要的事情说三遍，上面这篇文章就是给此文做准备的，所以此文就没有太多过程解释了

上文中讲了一些数字相关的东西，二进制转换、原码、反码、补码以及 JS 中的数字存储等等，看完上文再看此文会很 easy

也是给大家回顾下一些计算机基础常识，估计大家久征沙场这些基础都忘完了，不然直接啃会有点迷 😂





## 位运算

我们都知道，平常我们用来计算的是十进制的数值 `0~9` ，但是计算机是个机器，它只能识别二进制

根据国际 IEEE 754 标准，`JavaScript` 在存储数字时是始终以双精度浮点数来存储的，这种格式用 64 位二进制存储数值，64 位也就是 64 比特（bit），相当于 8 个字节，其中 0 到 51 存储数字（片段），52 到 62 存储指数，63 位存储符号

而在 JS 位运算中，并不会用 64 位来计算，它会先在后台把值转换为 32 位数值，再进行位运算操作，位运算计算完成后再将 32 位转为 64 位存储，整个过程就像在处理 32 位数值一样，所以我们了解位运算时，只需要关注这 32 位二进制整数就可以，因为 64 位存储格式是不可见的，但是也正是因为后台这个默认转换操作，给 JS 这门语言产生了一个副作用，即特殊值 NaN 和 Infinity 在位运算中都会直接被当作 0 来处理

其实不止是 JS ，很多语言的位运算都是如此，位运算符号一共分 7 个，知道了这些，我们开始逐个说位运算符



### 按位非 NOT（~）

#### 简述

按位非操作符也可以叫按位取反，它使用 `~` 符号表示，作用是对位取反，1 变成 0 ，0 变成 1

看过上文 「硬核JS」数字之美 的小伙伴们可能就会发现，这好像是取的反码？

是的，我们就可以直接理解为按位非就是取其二进制的反码，只不过，反码是符号位不变其余位置取反，而按位非则是取反码后符号位也取反



**例如：**

我们以 8 位（bit）数字存储为例

求十进制数字 2 的按位非，十进制数字 2 的二进制是 `0000 0010`，那么它的二进制反码就是 `0111 1101`，符号位也取反则变成了 `1111 1101`，当然你也可以直接将数字 2 的二进制每一位直接取反，结果都是 `1111 1101` 

我们知道符号位为 1 代表是负数，而计算机中存储负数是以补码的方式来存储的，所以我们对补码 `1111 1101` 求原码再转成十进制即可，对补码求原码就是使用此补码再求一遍补码，也就是先取反码再补 1 ，过程自算，得到了负数的二进制原码 `1000 00 11`，即十进制 `-3`  

同上所述

十进制数字 1 的按位非即十进制 `-2` 

十进制数字 0 的按位非即十进制 `-1`  

上面说的都是正数，我们看一个负数的例子

十进制数字 -1 由于是负数，上文我们说过计算机中二进制存储负数为补码方式，所以我们要先求 -1 的补码，-1 二进制原码是 `1000 0001`，再求原码的反码即 `1111 1110` ，接着补 1 即可求补码即 `1111 1111`，那么我们得到了 -1 在二进制中存储的的最终补码形态即为 `1111 1111` ，最终我们将此二进制每一位都取反得到 `0000 0000 `，即十进制数字 0



诶！好像有规律，我们试了几次之后发现按位非的最终结果始终是对原数值取反并减一，如下

```js
let a = 1
console.log(~a == (-a) - 1) // true

// 得到
~x = (-x) - 1
```

知道这个之后，我们遇到按位非操作符后可以根据这个规律来算结果，会比转二进制计算那样方便些

那么又有人说了，既然和 `(-x) - 1` 是一致的，那么为什么还要用按位非呢

很简单，原因有二，第一是位运算的操作是在数值底层表示上完成的，速度快。第二十因为它只用 2 个字符，比较方便。。。



#### 使用按位非判断是否等于-1

按位非在项目中的使用频率还是蛮高的

相信大家经常看到下面这种写法

```js
let str = "abcdefg"

if(!~str.indexOf("n")){
	console.log("字符串 str 中不存在字符 n")
}

// 等同于

if(str.indexOf("n") == "-1"){
  console.log("字符串 str 中不存在字符 n")
}
```

如上所示，我们知道 `indexOf` 方法在找不到相同值时返回 -1，而 `~-1 == 0 == false` ，所以 `!~-1 == 1 == true` ，一般来说我们使用按位非的写法来校验 -1 是用的最多，也是位运算中最容易令大家接受的了，是不是特别简单方便呢



#### 使用按位非取整

按位非的骚操作中，还有一个比较普遍的就是位运算双非取整了，如下所示

```js
~~3.14 == 3
```

很多人知道这样可以取整，但是由于不知道具体是为什么而不敢用，所以我们来解释下为什么它为什么可以取整

上面我们说过，在 JS 位运算中，并不会用 64 位来计算，它会先在后台把值转换为 32 位整数，再进行位运算操作，位运算计算完成后再将 32 位转为 64 位存储，整个过程就像在处理 32 位数值一样，所以我们了解位运算时，只需要关注这 32 位二进制整数就可以

这里我们可以看到，32 位 `整数`，位运算操作的是整数，后台在进行 64 位到 32 位转换时，会忽略掉小数部分

```js
~3.14 == ~3
-5.89 == ~5
```

如上所示，接着我们再按照上面的公式

```js
~x == (-x) - 1

~~x == -((-x) - 1) -1 == -(-x) + 1 -1 == x
```

所以位运算中的双非 `~~` 即可取整，此取整是完全忽略小数部分





### 按位与 AND（&）

#### 简述

按位与操作符也就是符号 `&` ，它有两个操作数，其实就是将两个操作数的二进制每一位进行对比，两个操作数相应的位都为 1 时，结果为 1，否则都为 0，如下

![](https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201122161948275.png)



**例如：** 

求 `25 & 3` ，即求十进制 25 和 十进制 3 的与操作值

我们分别求出 25 和 3 的二进制进行比对即可

```js
25 = 0000 0000 0000 0000 0000 0000 0001 1001
 3 = 0000 0000 0000 0000 0000 0000 0000 0011
--------------------------------------------
&  = 0000 0000 0000 0000 0000 0000 0000 0001
```

如上所示，最终我们比对的二进制结果为 `0000 ... 0001`，即十进制数字 1



#### 使用按位与判断奇偶数

按位与这个东西平常用的不太多，我一般只会在判断奇偶数的才会用到，如下：

```js
偶数 & 1 // 0
奇数 & 1 // 1
```

因为十进制数字 1 的二进制为 `0000 ... 0001`，只有最后一位为 1，其余位都是 0 ，所以任何数字和它对比除最后一位其余都是 0，那么当这个数字末位为 1 时，也就是奇数，那么结果就是 1，这个数字末位为 0 时，也就是偶数，那么结果就是 0，毕竟二进制只有 0 和 1





### 按位或 OR（｜）

#### 简述

按位或用符号 `|` 来表示，它也有两个操作数，按位或也是将两个操作数二进制的每一位进行对比，只不过按位或是两边只要有一个 1 ，结果就是 1，只有两边都是 0 ，结果才为 0，如下

![](https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201122171909201.png)



**例如：** 

求 `25 ｜ 3` ，即求十进制 25 和 十进制 3 的或操作值

我们分别求出 25 和 3 的二进制进行比对即可

```js
25 = 0000 0000 0000 0000 0000 0000 0001 1001
 3 = 0000 0000 0000 0000 0000 0000 0000 0011
--------------------------------------------
|  = 0000 0000 0000 0000 0000 0000 0001 1011
```

如上所示，最终我们比对的二进制结果为 `0000 ... 0001 1011`，即十进制数字 27





### 按位异或 XOR（^）

#### 简述

按位异或使用字符 `^` 来表示，按位异或和按位或的区别其实就是在比对时，按位异或只在一位是 1 时返回 1，两位都是 1 或者两位都是 0 都返回 0，如下

![](https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201122172631261.png)



**例如：** 

求 `25 ^ 3` ，即求十进制 25 和 十进制 3 的异或值

我们分别求出 25 和 3 的二进制进行比对即可

```js
25 = 0000 0000 0000 0000 0000 0000 0001 1001
 3 = 0000 0000 0000 0000 0000 0000 0000 0011
--------------------------------------------
|  = 0000 0000 0000 0000 0000 0000 0001 1010
```

如上所示，最终我们比对的二进制结果为 `0000 ... 0001 1010`，即十进制数字 26





### 左移（<<）

#### 简述

左移用符号 `<<` 来表示，正如它的名字，即将数值的二进制码按照指定的位数向左移动，符号位不变



**例如： ** 

求 `2 << 5`，即求十进制数 2 左移 5 位的操作

我们先将十进制数字 2 转二进制再左移 5 位后如下图

![](https://gitee.com/IsboyJC/PictureBed/raw/master/other/image-20201122175424438.png)

我们得到了一个新的二进制转为 10 进制即为数值 64

数字 x 左移 y 位我们其实可以得到一个公式，如下

```js
x << y 

// 等同于

x * 2^y
```





### 有符号右移（>>）

#### 简述





### 无符号右移（>>>）

#### 简述





